name: Add PR to Project and Auto-Merge

on:
  workflow_dispatch:
  pull_request:
    types: [opened, edited, reopened, closed]
    branches:
      - main
      - master

jobs:
  manage-pr:
    runs-on: ubuntu-latest
    steps:
      - name: Manage PR in Project
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            if (!pr) { console.log('No PR context'); return; }
            
            const action = context.payload.action;
            console.log('Action: ' + action);
            console.log('Processing PR #' + pr.number + ': ' + pr.title);
            
            // Get project and its fields
            const projectData = await github.graphql(`
              query($org: String!, $number: Int!) {
                organization(login: $org) {
                  projectV2(number: $number) {
                    id
                    fields(first: 20) {
                      nodes {
                        ... on ProjectV2Field {
                          id
                          name
                        }
                        ... on ProjectV2SingleSelectField {
                          id
                          name
                          options {
                            id
                            name
                          }
                        }
                      }
                    }
                  }
                }
              }`, { org: 'test-org-payal', number: 2 });
            
            const projectId = projectData.organization.projectV2.id;
            const fields = projectData.organization.projectV2.fields.nodes;
            
            // Find field IDs
            const releaseNotesField = fields.find(f => f.name === 'Release Notes');
            const deployNotesField = fields.find(f => f.name === 'Deployment Notes');
            const dependenciesField = fields.find(f => f.name === 'Dependencies');
            let mergeStatusField = fields.find(f => f.name === 'Merge Status');
            
            // Create Merge Status field if it doesn't exist
            if (!mergeStatusField) {
              console.log('Creating Merge Status field...');
              try {
                const createFieldResult = await github.graphql(`
                  mutation($projectId: ID!, $name: String!, $dataType: ProjectV2CustomFieldType!) {
                    createProjectV2Field(input: {
                      projectId: $projectId
                      dataType: $dataType
                      name: $name
                      singleSelectOptions: [
                        {name: "Not Merged", color: GRAY},
                        {name: "Merged", color: GREEN}
                      ]
                    }) {
                      projectV2Field {
                        ... on ProjectV2SingleSelectField {
                          id
                          name
                          options {
                            id
                            name
                          }
                        }
                      }
                    }
                  }`, {
                    projectId: projectId,
                    name: 'Merge Status',
                    dataType: 'SINGLE_SELECT'
                  });
                mergeStatusField = createFieldResult.createProjectV2Field.projectV2Field;
                console.log('✅ Merge Status field created');
              } catch (e) {
                console.log('⚠️ Could not create field:', e.message);
              }
            }
            
            // Find existing item in project
            const findExistingItem = async () => {
              const findQuery = await github.graphql(`
                query($projectId: ID!) {
                  node(id: $projectId) {
                    ... on ProjectV2 {
                      items(first: 100) {
                        nodes {
                          id
                          content {
                            ... on PullRequest {
                              number
                              repository { name }
                            }
                          }
                        }
                      }
                    }
                  }
                }`, { projectId });
              return findQuery.node.items.nodes.find(
                item => item.content?.number === pr.number && 
                        item.content?.repository?.name === context.repo.repo
              );
            };
            
            // Handle PR deletion/closure
            if (action === 'closed') {
              console.log('\n--- PR Closed/Merged - Removing from Project ---');
              const existingItem = await findExistingItem();
              if (existingItem) {
                try {
                  await github.graphql(`
                    mutation($projectId: ID!, $itemId: ID!) {
                      deleteProjectV2Item(input: {projectId: $projectId, itemId: $itemId}) {
                        deletedItemId
                      }
                    }`, { projectId: projectId, itemId: existingItem.id });
                  console.log('✅ PR removed from project');
                } catch (e) {
                  console.error('❌ Error removing PR:', e.message);
                }
              } else {
                console.log('PR not found in project');
              }
              return;
            }
            
            // Add or get PR in project
            console.log('\n--- Adding/Updating PR in Project ---');
            let itemId = null;
            
            try {
              const addResult = await github.graphql(`
                mutation($projectId: ID!, $contentId: ID!) {
                  addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) {
                    item { id }
                  }
                }`, { projectId: projectId, contentId: pr.node_id });
              itemId = addResult.addProjectV2ItemById.item.id;
              console.log('✅ PR added to project');
            } catch (e) {
              if (e.message.includes('already')) {
                console.log('ℹ️ Already in project');
                const existingItem = await findExistingItem();
                if (existingItem) itemId = existingItem.id;
              } else {
                console.error('❌ Error:', e.message);
              }
            }
            
            // Extract notes from PR body
            const body = pr.body || '';
            const releaseMatch = body.match(/## Release Notes\s*\n+([\s\S]*?)(?=\n##|$)/i);
            const releaseNotes = releaseMatch ? releaseMatch[1].trim() : '';
            
            const deployMatch = body.match(/## Deployment Notes\s*\n+([\s\S]*?)(?=\n##|$)/i);
            const deployNotes = deployMatch ? deployMatch[1].trim() : '';
            
            const dependencyMatch = body.match(/## Dependencies\s*\n+([\s\S]*?)(?=\n##|$)/i);
            const dependencies = dependencyMatch ? dependencyMatch[1].trim() : '';
            
            // Determine merge status based on PR state
            const hasReleaseNotes = releaseNotes && !releaseNotes.startsWith('<!--') && releaseNotes.length > 0;
            const hasDeployNotes = deployNotes && !deployNotes.startsWith('<!--') && deployNotes.length > 0;
            const hasDependencies = dependencies && !dependencies.startsWith('<!--') && dependencies.length > 0;
            
            let mergeStatus = pr.merged ? 'Merged' : 'Not Merged';
            
            // Define update functions
            const updateTextField = async (fieldId, value) => {
              if (!fieldId || !value) return;
              try {
                await github.graphql(`
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $value: String!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId
                      itemId: $itemId
                      fieldId: $fieldId
                      value: { text: $value }
                    }) {
                      projectV2Item { id }
                    }
                  }`, {
                    projectId: projectId,
                    itemId: itemId,
                    fieldId: fieldId,
                    value: value.substring(0, 1024)
                  });
              } catch (e) {
                console.log('Warning: Could not update text field -', e.message);
              }
            };
            
            const updateSelectField = async (fieldId, optionName) => {
              if (!fieldId || !optionName || !itemId) return;
              try {
                const field = fields.find(f => f.id === fieldId);
                const option = field?.options?.find(o => o.name === optionName);
                if (!option) {
                  console.log('Option not found:', optionName);
                  return;
                }
                
                await github.graphql(`
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId
                      itemId: $itemId
                      fieldId: $fieldId
                      value: { singleSelectOptionId: $optionId }
                    }) {
                      projectV2Item { id }
                    }
                  }`, {
                    projectId: projectId,
                    itemId: itemId,
                    fieldId: fieldId,
                    optionId: option.id
                  });
              } catch (e) {
                console.log('Warning: Could not update select field -', e.message);
              }
            };
            
            // Update project fields
            if (itemId) {
              if (releaseNotes) await updateTextField(releaseNotesField?.id, releaseNotes);
              if (deployNotes) await updateTextField(deployNotesField?.id, deployNotes);
              if (dependencies) await updateTextField(dependenciesField?.id, dependencies);
              await updateSelectField(mergeStatusField?.id, mergeStatus);
              
              console.log('✅ Project fields updated');
              console.log('   Merge Status: ' + mergeStatus);
            }
            
            // Check if ready to merge
            console.log('\n--- Checking Merge Conditions ---');
            const requiredFailed = [];
            const optionalStatus = [];
            
            if (!hasReleaseNotes) requiredFailed.push('❌ Release notes not added (REQUIRED)');
            else console.log('✅ Release notes added');
            
            if (!hasDeployNotes) requiredFailed.push('❌ Deployment notes not added (REQUIRED)');
            else console.log('✅ Deployment notes added');
            
            if (hasDependencies) {
              optionalStatus.push('✅ Dependencies documented');
              console.log('✅ Dependencies (optional)');
            } else {
              optionalStatus.push('ℹ️ Dependencies not documented (optional)');
              console.log('ℹ️ Dependencies not documented (optional)');
            }
            
            console.log('\n--- Merge Decision ---');
            if (requiredFailed.length > 0) {
              console.log('❌ Cannot merge');
              requiredFailed.forEach(f => console.log('   ' + f));
              
              const commentBody = '## ⏳ Merge Checklist\n\n**Required (must complete):**\n' + requiredFailed.join('\n') + '\n\n**Optional:**\n' + optionalStatus.join('\n') + '\n\nPlease complete all required items.';
              
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number
              });
              const botComment = comments.data.find(c => c.user.type === 'Bot' && c.body.includes('Merge Checklist'));
              
              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner, repo: context.repo.repo,
                  comment_id: botComment.id, body: commentBody
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner, repo: context.repo.repo,
                  issue_number: pr.number, body: commentBody
                });
              }
              return;
            }
            
            console.log('✅ All checks passed - merging');
            try {
              let commitMessage = 'Release Notes:\n' + releaseNotes + '\n\nDeployment Notes:\n' + deployNotes;
              if (hasDependencies) commitMessage += '\n\nDependencies:\n' + dependencies;
              
              await github.rest.pulls.merge({
                owner: context.repo.owner, repo: context.repo.repo, pull_number: pr.number,
                merge_method: 'squash',
                commit_title: pr.title + ' (#' + pr.number + ')',
                commit_message: commitMessage
              });
              console.log('✅ Merged!');
              
              // Update status to "Merged" after successful merge
              if (itemId && mergeStatusField) {
                await updateSelectField(mergeStatusField.id, 'Merged');
              }
              
              const successBody = '## ✅ Auto-Merged!\n\nAll required checks passed.\n\n**Included:**\n- ✅ Release notes\n- ✅ Deployment notes' + (hasDependencies ? '\n- ✅ Dependencies' : '');
              
              await github.rest.issues.createComment({
                owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number,
                body: successBody
              });
            } catch (e) {
              console.error('❌ Merge error:', e.message);
              await github.rest.issues.createComment({
                owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number,
                body: '❌ Auto-merge failed: ' + e.message
              });
            }
