name: Add PR to Project

on:
  workflow_dispatch:
  pull_request:
    types: [opened, edited, reopened]
    branches:
      - main
      - master

jobs:
  add-to-project-and-merge:
    runs-on: ubuntu-latest
    steps:
      - name: Add PR to Project and Check Merge Conditions
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            if (!pr) { console.log('No PR context'); return; }
            console.log('Processing PR #' + pr.number + ': ' + pr.title);
            
            console.log('\n--- Adding to Project ---');
            const projectData = await github.graphql(`
              query($org: String!, $number: Int!) {
                organization(login: $org) { projectV2(number: $number) { id } }
              }`, { org: 'test-org-payal', number: 2 });
            const projectId = projectData.organization.projectV2.id;
            
            try {
              await github.graphql(`mutation($projectId: ID!, $contentId: ID!) {
                addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) { item { id } }
              }`, { projectId: projectId, contentId: pr.node_id });
              console.log('✅ PR added to project');
            } catch (e) {
              if (e.message.includes('already')) console.log('ℹ️ Already in project');
              else console.error('❌ Error:', e.message);
            }
            
            console.log('\n--- Checking Conditions ---');
            const body = pr.body || '';
            const requiredFailed = [];
            const optionalStatus = [];
            
            const releaseMatch = body.match(/## Release Notes\s*\n+([\s\S]*?)(?=\n##|$)/i);
            const releaseNotes = releaseMatch ? releaseMatch[1].trim() : '';
            const hasReleaseNotes = releaseNotes && !releaseNotes.startsWith('<!--') && releaseNotes.length > 0;
            if (!hasReleaseNotes) requiredFailed.push('❌ Release notes not added (REQUIRED)');
            else console.log('✅ Release notes added');
            
            const deployMatch = body.match(/## Deployment Notes\s*\n+([\s\S]*?)(?=\n##|$)/i);
            const deployNotes = deployMatch ? deployMatch[1].trim() : '';
            const hasDeployNotes = deployNotes && !deployNotes.startsWith('<!--') && deployNotes.length > 5;
            if (!hasDeployNotes) requiredFailed.push('❌ Deployment notes not added (REQUIRED)');
            else console.log('✅ Deployment notes added');
            
            const dependencyMatch = body.match(/## Dependencies\s*\n+([\s\S]*?)(?=\n##|$)/i);
            const dependencies = dependencyMatch ? dependencyMatch[1].trim() : '';
            const hasDependencies = dependencies && !dependencies.startsWith('<!--') && dependencies.length > 0;
            if (hasDependencies) {
              optionalStatus.push('✅ Dependencies documented');
              console.log('✅ Dependencies (optional)');
            } else {
              optionalStatus.push('ℹ️ Dependencies not documented (optional)');
              console.log('ℹ️ Dependencies not documented (optional)');
            }
            
            console.log('\n--- Merge Decision ---');
            if (requiredFailed.length > 0) {
              console.log('❌ Cannot merge');
              requiredFailed.forEach(f => console.log('   ' + f));
              
              const commentBody = '## ⏳ Merge Checklist\n\n**Required (must complete):**\n' + requiredFailed.join('\n') + '\n\n**Optional:**\n' + optionalStatus.join('\n') + '\n\nPlease complete all required items.';
              
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number
              });
              const botComment = comments.data.find(c => c.user.type === 'Bot' && c.body.includes('Merge Checklist'));
              
              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner, repo: context.repo.repo,
                  comment_id: botComment.id, body: commentBody
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner, repo: context.repo.repo,
                  issue_number: pr.number, body: commentBody
                });
              }
              return;
            }
            
            console.log('✅ All checks passed - merging');
            try {
              let commitMessage = 'Release Notes:\n' + releaseNotes + '\n\nDeployment Notes:\n' + deployNotes;
              if (hasDependencies) commitMessage += '\n\nDependencies:\n' + dependencies;
              
              await github.rest.pulls.merge({
                owner: context.repo.owner, repo: context.repo.repo, pull_number: pr.number,
                merge_method: 'squash',
                commit_title: pr.title + ' (#' + pr.number + ')',
                commit_message: commitMessage
              });
              console.log('✅ Merged!');
              
              const successBody = '## ✅ Auto-Merged!\n\nAll required checks passed.\n\n**Included:**\n- ✅ Release notes\n- ✅ Deployment notes' + (hasDependencies ? '\n- ✅ Dependencies' : '');
              
              await github.rest.issues.createComment({
                owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number,
                body: successBody
              });
            } catch (e) {
              console.error('❌ Merge error:', e.message);
              await github.rest.issues.createComment({
                owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number,
                body: '❌ Auto-merge failed: ' + e.message
              });
            }
